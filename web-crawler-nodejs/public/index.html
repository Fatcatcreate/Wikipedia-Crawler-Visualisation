<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web Crawler Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css"
      rel="stylesheet"
    />
    <style>
      #mynetwork {
        width: 100%;
        height: 800px;
        border: 1px solid lightgray;
        margin-bottom: 20px;
      }
      #sliderContainer {
        margin-bottom: 20px;
      }
      #sliderLabel {
        margin-right: 10px;
      }
    </style>
  </head>
  <body>
    <h2>Web Crawler Visualization</h2>

    <!-- Slider to control number of nodes -->
    <div id="sliderContainer">
      <label for="nodeSlider" id="sliderLabel"
        >Number of nodes to display: 10</label
      >
      <input type="range" id="nodeSlider" min="10" max="5000" value="10" />
    </div>

    <div id="mynetwork"></div>

    <script>
      // Fetch the pageLinkMapping.json file from the server
      fetch("pageLinkMapping.json")
        .then((response) => response.json())
        .then((pageLinkMapping) => {
          // Prepare the nodes and edges for Vis.js
          const nodes = new vis.DataSet();
          const edges = new vis.DataSet();

          // Map to store node ids
          const urlToIdMap = new Map();
          let idCounter = 1;

          // Helper function to extract the last meaningful part of the URL
          function extractLabel(url) {
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            const segments = pathname.split("/").filter(Boolean);
            return segments.length > 0 ? segments[segments.length - 1] : url;
          }

          // Helper function to add a node with extracted label
          function addNode(url) {
            if (!urlToIdMap.has(url)) {
              const label = extractLabel(url); // Get only the last part of the URL
              urlToIdMap.set(url, idCounter);
              nodes.add({ id: idCounter, label: label });
              idCounter++;
            }
            return urlToIdMap.get(url);
          }

          // Helper function to add edges for a node
          function addEdgesForNode(nodeId) {
            const pageData = pageLinkMapping.find(
              (page) => urlToIdMap.get(page.page) === nodeId
            );
            if (pageData) {
              pageData.links.forEach((link) => {
                const linkId = addNode(link);
                if (
                  !edges.get({
                    filter: (item) =>
                      item.from === nodeId && item.to === linkId,
                  }).length
                ) {
                  edges.add({ from: nodeId, to: linkId, color: "red" }); // Add connection in red
                }
              });
            }
          }

          // Function to update the graph based on the number of nodes
          function updateGraph(nodeCount) {
            nodes.clear();
            edges.clear();
            urlToIdMap.clear();
            idCounter = 1;

            // Filter out pages with fewer than 3 connections (links)
            const filteredPageLinkMapping = pageLinkMapping.filter(
              (pageData) => pageData.links.length >= 3
            );

            // Add the specified number of nodes
            const initialNodes = filteredPageLinkMapping
              .slice(0, nodeCount)
              .map((pageData) => addNode(pageData.page));

            // Add edges for each node
            initialNodes.forEach((nodeId) => addEdgesForNode(nodeId));
          }

          // Initialize the network
          const container = document.getElementById("mynetwork");
          const data = { nodes, edges };
          const options = {
            nodes: {
              shape: "dot",
              size: 16,
              font: { size: 14 },
            },
            edges: {
              arrows: { to: true },
              smooth: { type: "continuous" },
            },
            physics: {
              enabled: true,
              solver: "barnesHut",
              barnesHut: {
                gravitationalConstant: -5000,
                springConstant: 0.005,
              },
              stabilization: {
                iterations: 200,
                fit: true,
              },
            },
          };

          const network = new vis.Network(container, data, options);

          // Event listener for node click to expand connections
          network.on("click", function (params) {
            if (params.nodes.length > 0) {
              const clickedNodeId = params.nodes[0];
              addEdgesForNode(clickedNodeId); // Add connections when clicked
            }
          });

          // Add event listener to the slider
          const slider = document.getElementById("nodeSlider");
          const sliderLabel = document.getElementById("sliderLabel");

          slider.addEventListener("input", (event) => {
            const nodeCount = event.target.value;
            sliderLabel.textContent = `Number of nodes to display: ${nodeCount}`;
            updateGraph(nodeCount);
          });

          // Initialize the graph with the default value of 50 nodes
          updateGraph(10);
        })
        .catch((error) => {
          console.error("Error loading pageLinkMapping.json:", error);
        });
    </script>
  </body>
</html>
